grammar GrammarLexer;

IF: 'if';
ELSE: 'else';
fragment LETTER: [a-zA-Z];
fragment DIGIT: [0-9];
TRUE: 'true';
FALSE: 'false';
LBRACKET: '(';
RBRACKET: ')';
LSBRACKET: '[';
RSBRACKET: ']';
LCBRACKET: '{';
RCBRACKET: '}';
COMMA: ',';
DOT: '.';
ADD: '+';
SUBTRACT: '-';
MULTIPLY: '*';
DIVIDE: '/';
GREATER: '>';
GREATER_EQUAL: '>=';
LESS: '<';
LESS_EQUAL: '<=';
EQUAL: '==';
DIFFERENT: '!=';
WHILE: 'while';
RETURN: 'return';
INT: 'int';
BOOL: 'bool';
PRINT: 'print';
ASSIGN: '=';
NUMBER: DIGIT+;
IDENTIFIER: LETTER (LETTER | DIGIT)*;
NEWLINE: '\r'?'\n'  -> skip ;

PROGRAM: FUNCTION*;

FUNCTION: 'function' IDENTIFIER LPAR [PARAMLIST] RPAR LCBRACKET STMTLIST RBBRACKET;

PARAMLIST: PARAM | PARAM COMMA PARAMLIST;

PARAM: IDENTIFIER;

STMTLIST: STMT | STMT STMTLIST;

STMT: ASSIGN | IF | WHILE | SEQUENCE | RETURNSTMT SEMICOLON;

ASSIGN: IDENTIFIER EQUAL EXPR | IDENTIFIER EQUAL FUNCCALL;

IF: IF LBRACKET EXPR RBRACKET STMT ELSE STMT;

WHILE: WHILE LBRACKET EXPR RBRACKET STMT;

SEQUENCE: LCBRACKET STMTLIST RCBRACKET;

RETURNSTMT: RETURN EXPR;

EXPR: ARITHEXPR | BOOLEXPR;

ARITHEXPR: NOPRND | BINOPRND;

BOOLEXPR: BOPRND | RELOP;

BINOP: NOPRND OP NOPRND;